//Sorry only in russian.

Problem 1.
  Выбор региона пользователем.
    Варианты:
    1. Запрос на координаты первой точки, потом второй.
      Проблема: Неудобно тем, что надо считать где какая координата.
        Решение? в клеточках писать координаты. (Некрасиво, много информации)
    2. Изначально два указателя, выбераем через 0/1 какой двигать. Двигать стрелочками?
      Постоянно отображать пересечение прямых, в центре которых текущее положение указателя.
      Проблема: Неудобно смотреть куда двигать. Неудобно двигать? (Можно ли двигать стрелочками???)
        Решение: Вместо прямых просто выделять квадрат в которм указатель.
    3*. Вывести на экран текущее поле, так что-бы его можно было менять.
      Проблема варианта: Нельзя запретить пользователю выбрать не один регион. (Поведение неадекватное)
      3.1. Тогда можно к примеру попросить игрока выделить желаемый регион и удалить.
      (Вопрос в том как сделать так, что-бы не сместились клетки, и адекватно распознать изменения)
      3.2. Попросить поставить в нужных точках определённый символ/цифру.
        Проблема: Не слишком удобно, и затратно по времени* выискивать изменённые клетки. *На больших обьёмах
  Пока выбор остановлю на первом варианте.

!!! НЕ забыть !!! после генерации лабиринта спросить норм ли. Потом дать инструмент добавления предметов интерьера.
/* char in circles
     * 0x024b6	-  0x024ff
     * different stuff
     * 0x02500  -  0x025ef
     * */

#define _CRT_SECURE_NO_WARNINGS

#include <iostream>
#include <wchar.h>
#include <locale.h>
#include <string.h>

void printwc(wchar_t wc)
{
    char buf[2 * MB_CUR_MAX];

    mbstate_t state;
    memset(&state,0,sizeof(state));

    size_t offset1 = wcrtomb(buf, wc, &state);

    if(offset1 == size_t(-1))
    {
        std::cerr << "wcrtomb failed (1)" << std::endl;
        return;
    }

    size_t offset2 = wcrtomb(buf + offset1, L'\0', &state);

    if(offset2 == size_t(-1))
    {
        std::cerr << "wcrtomb failed (2)" << std::endl;
        return;
    }

    std::cout << buf << std::endl;
}

int main()
{
    setlocale(LC_ALL, "");

    printwc(0x1f0a1);
    for(auto i = 0x024b6; i <= 0x024ff; i++){
        printwc(i);
    }
    for(auto i = 0x02500; i <= 0x025ef; i++){
        printwc(i);
    }
    /* char in circles
     * 0x024b6	-  0x024ff
     * different stuff
     * 0x02500  -  0x025ef
     * */
    return 0;
}
